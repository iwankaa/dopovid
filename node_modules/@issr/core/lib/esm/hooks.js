import { useContext, useState, useRef, useMemo, useEffect, useCallback, } from 'react';
import { Effect } from './effect';
import { IssrContext } from './i-ssr';
import { isBackend } from './utils';
export const useSsrState = (initialState, id) => {
    if (typeof id !== 'string') {
        throw new Error('"useSsrState" hook: id is not a string. iSSR required @issr/babel-loader. You can follow official documentation to setup your build system https://github.com/AlexSergey/issr#usage');
    }
    const { initState } = useContext(IssrContext);
    const appStateFragment = useMemo(() => (typeof initState[id] === 'undefined' ? initialState : initState[id]), [initState, id, initialState]);
    const [state, setState] = useState(appStateFragment);
    const modifiedSetState = useCallback((innerState) => {
        const s = innerState instanceof Function ? innerState(initState[id]) : innerState;
        initState[id] = s;
        setState(s);
    }, []);
    useEffect(() => () => {
        // Clear Global state when component was unmounted
        initState[id] = undefined;
        delete initState[id];
    }, []);
    return [state, modifiedSetState];
};
export const useSsrEffect = (effect, deps, id) => {
    // eslint-disable-next-line no-nested-ternary
    const effectId = Array.isArray(deps) ? id : typeof deps === 'string' ? deps : false;
    if (typeof effectId !== 'string') {
        throw new Error('"useSsrEffect" hook: id is not a string. iSSR required @issr/babel-loader. You can follow official documentation to setup your build system https://github.com/AlexSergey/issr#usage');
    }
    const initHook = useRef(true);
    const cb = useRef(effect);
    const { isLoading, setEffectCalledState, getEffectCalledState } = useContext(IssrContext);
    const isCalled = getEffectCalledState(effectId);
    const loading = isLoading();
    const isClient = !isBackend();
    const firstLoadingOnTheClient = isClient && loading && initHook.current;
    const firstLoadingOnTheBackend = isBackend() && initHook.current && !isCalled;
    initHook.current = false;
    const allDeps = Array.isArray(deps) ? deps : [];
    useEffect(() => {
        cb.current = effect;
    }, [effect]);
    // Effect on the backend side must run synchronously
    if (firstLoadingOnTheBackend) {
        effect();
        setEffectCalledState(effectId);
    }
    useEffect(() => {
        // First call after hydration must be skipped on the client side
        if (firstLoadingOnTheClient) {
            return;
        }
        // Already called in the backend side
        if (firstLoadingOnTheBackend) {
            return;
        }
        if (typeof cb.current === 'function') {
            // eslint-disable-next-line consistent-return
            return cb.current();
        }
    }, allDeps.concat([firstLoadingOnTheBackend, firstLoadingOnTheClient]));
};
export const useRegisterEffect = (id) => {
    if (typeof id !== 'string') {
        throw new Error('"useRegisterEffect" hook: id is not a string. iSSR required @issr/babel-loader. You can follow official documentation to setup your build system https://github.com/AlexSergey/issr#usage');
    }
    const { effectCollection } = useContext(IssrContext);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (cb, ...args) => {
        const res = cb(...args);
        if (!effectCollection.getEffect(id)) {
            const effect = new Effect({ id });
            effectCollection.addEffect(effect);
            if (res instanceof Promise) {
                effect.addCallback(res);
            }
        }
        return res;
    };
};
//# sourceMappingURL=hooks.js.map