import { __awaiter } from "tslib";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
/**
 * @jest-environment node
 */
import { useSsrState, useSsrEffect, useRegisterEffect } from './hooks';
import { serverRender } from './server';
describe('server render tests', () => {
    test('pure state', () => __awaiter(void 0, void 0, void 0, function* () {
        const App = () => {
            const [state, setState] = useSsrState('', 'state-0');
            const registerEffect = useRegisterEffect('effect-0');
            const asyncFn = () => new Promise((resolve) => {
                setTimeout(() => {
                    resolve('test bar');
                }, 500);
            });
            useSsrEffect(() => {
                registerEffect(asyncFn).then((testBar) => {
                    setState(testBar);
                });
            }, [], 'use-effect-0');
            return _jsx("div", { children: state }, void 0);
        };
        const { html, state } = yield serverRender.string(() => _jsx(App, {}, void 0));
        const key = Object.keys(state)[0];
        expect(html).toBe('<div>test bar</div>');
        expect(state).toStrictEqual({ [key]: 'test bar' });
    }));
    test('pure state and external callback', () => __awaiter(void 0, void 0, void 0, function* () {
        let called = false;
        const outsideEffect = () => new Promise((resolve) => {
            setTimeout(() => {
                called = true;
                resolve();
            }, 500);
        });
        const externalCallback = () => __awaiter(void 0, void 0, void 0, function* () {
            if (!called) {
                yield outsideEffect();
            }
        });
        const App = () => {
            const [state, setState] = useSsrState('', 'state-0');
            const registerEffect = useRegisterEffect('effect-0');
            const asyncFn = () => new Promise((resolve) => {
                setTimeout(() => {
                    resolve('test bar');
                }, 500);
            });
            useSsrEffect(() => {
                registerEffect(asyncFn).then((data) => {
                    setState(data);
                });
            }, [], 'use-effect-0');
            return _jsx("div", { children: state }, void 0);
        };
        const { html, state } = yield serverRender.string(() => _jsx(App, {}, void 0), {
            outsideEffects: externalCallback,
        });
        const key = Object.keys(state)[0];
        expect(called).toBe(true);
        expect(html).toBe('<div>test bar</div>');
        expect(state).toStrictEqual({ [key]: 'test bar' });
    }));
    test('nested effects', () => __awaiter(void 0, void 0, void 0, function* () {
        const asyncFn1 = () => new Promise((resolve) => 
        // eslint-disable-next-line no-promise-executor-return
        setTimeout(() => resolve({
            show: true,
            value: 'Wrapper Component',
        }), 300));
        const Wrapper = ({ children }) => {
            const [state, setState] = useSsrState({ show: false, value: 'none ' }, 'state-0');
            const registerEffect = useRegisterEffect('effect-0');
            useSsrEffect(() => {
                registerEffect(asyncFn1).then((data) => {
                    setState(data);
                });
            }, [], 'use-effect-0');
            return (_jsxs("div", { children: [_jsx("p", { children: state.value }, void 0), state.show && children] }, void 0));
        };
        const asyncFn2 = () => new Promise((resolve) => 
        // eslint-disable-next-line no-promise-executor-return
        setTimeout(() => resolve({
            show: true,
            value: 'A Component',
        }), 300));
        const A = ({ children }) => {
            const [state, setState] = useSsrState({ show: false, value: 'none ' }, 'state-1');
            const registerEffect = useRegisterEffect('effect-1');
            useSsrEffect(() => {
                registerEffect(asyncFn2).then((data) => {
                    setState(data);
                });
            }, [], 'use-effect-1');
            return (_jsxs("div", { children: [_jsx("p", { children: state.value }, void 0), state.show && children] }, void 0));
        };
        const asyncFn3 = () => 
        // eslint-disable-next-line no-promise-executor-return
        new Promise((resolve) => setTimeout(() => resolve('B Component'), 300));
        const B = () => {
            const [state, setState] = useSsrState('none', 'state-2');
            const registerEffect = useRegisterEffect('effect-2');
            useSsrEffect(() => {
                registerEffect(asyncFn3).then((data) => {
                    setState(data);
                });
            }, [], 'use-effect-2');
            return (_jsx("div", { children: _jsx("p", { children: state }, void 0) }, void 0));
        };
        // eslint-disable-next-line no-promise-executor-return
        const asyncFn4 = () => new Promise((resolve) => setTimeout(() => resolve('C Component'), 300));
        const C = () => {
            const [state, setState] = useSsrState('none', 'state-3');
            const registerEffect = useRegisterEffect('effect-3');
            useSsrEffect(() => {
                registerEffect(asyncFn4).then((data) => {
                    setState(data);
                });
            }, [], 'use-effect-3');
            return (_jsx("div", { children: _jsx("p", { children: state }, void 0) }, void 0));
        };
        const App = () => (_jsxs(Wrapper, { children: [_jsx(A, { children: _jsx(B, {}, void 0) }, void 0), _jsx(C, {}, void 0)] }, void 0));
        const { html, state } = yield serverRender.string(() => _jsx(App, {}, void 0));
        expect(html).toBe('<div><p>Wrapper Component</p><div><p>A Component</p><div><p>B Component</p></div></div><div><p>C Component</p></div></div>');
        expect(state).toStrictEqual({
            'state-0': { show: true, value: 'Wrapper Component' },
            'state-1': { show: true, value: 'A Component' },
            'state-2': 'B Component',
            'state-3': 'C Component',
        });
    }));
});
//# sourceMappingURL=server.spec.js.map